<!doctype html>
<html lang='en'>

<head>

	<meta charset='utf-8' />

	<script src='./js/react.development.js'></script>
	<script src='./js/react-dom.development.js'></script>
	<script src='./js/babel.min.js'></script>

	<script src='./js/three.min.js'></script>
	<script src='./js/OrbitControls.js'></script>

	<script src='./js/TweenMax.min.js'></script>

	<title>
		nomDAO
	</title>

</head>

<style>

	body {
		margin      : 0;
		font-family : Arial ;
		font-size   : 17px;
		color       : white ;
		overflow    : hidden ;
	}

	/* card css by BD start */
	.card_flag_img {
		margin-bottom: 5px;
		height: 20px;
	}

	.card_flag_img img {
		margin-bottom: 0px;
	}

	/* .main-container {
		display: flex;
		flex-direction: row;
		position: relative;
	} */

	/* .globe-main {
		position: absolute;
		left: 20%;
	} */

	.card_info_main h3 {
		font-family: 'Poppins', sans-serif;
		font-size: 17px;
		font-style: normal;
		font-weight: 600;
		line-height: 28px;
		letter-spacing: 0em;
		text-align: left;
		padding-bottom: 4px;
		margin: 0;
		color : black ;
		z-index : 10 ;
	}

	.card_info_main p {
		font-family: 'Work Sans', sans-serif;
		font-size: 14px;
		font-style: normal;
		font-weight: 400;
		line-height: 16px;
		letter-spacing: 0em;
		text-align: left;
		margin: 0;
	}

	/* card css by BD end */

	.w100h100 {
		width: 100%;
		height: 100%;
	}

	.Card_div {
		position: absolute;
		color: black;
		padding-top    : 20px ;
		padding-bottom : 10px ;
		padding-left   : 30px ;
		padding-right  : 30px ;
		opacity: .8;
		border-radius: 25px;
	}

	.canvas_div {
		position: absolute;
		background: rgba(39, 39, 53, 0.9);
	}

	.animate {
		-webkit-animation: animatezoom 0.6s;
		animation: animatezoom 0.6s;
	}

	@-webkit-keyframes animatezoom {
		from {
			-webkit-transform: scale(0)
		}

		to {
			-webkit-transform: scale(1)
		}
	}

	@keyframes animatezoom {
		from {
			transform: scale(0)
		}

		to {
			transform: scale(1)
		}
	}

	.fade-in-image {
		animation: fadeIn 1s;
		-webkit-animation: fadeIn 1s;
		-moz-animation: fadeIn 1s;
		-o-animation: fadeIn 1s;
		-ms-animation: fadeIn 1s;
	}

	@keyframes fadeIn {
		0% {
			opacity: 0;
		}

		100% {
			opacity: 0.8;
		}
	}

	@-moz-keyframes fadeIn {
		0% {
			opacity: 0;
		}

		100% {
			opacity: 0.8;
		}
	}

	@-webkit-keyframes fadeIn {
		0% {
			opacity: 0;
		}

		100% {
			opacity: 0.8;
		}
	}

	@-o-keyframes fadeIn {
		0% {
			opacity: 0;
		}

		100% {
			opacity: 0.8;
		}
	}

	@-ms-keyframes fadeIn {
		0% {
			opacity: 0;
		}

		100% {
			opacity: 0.8;
		}
	}

	.globe-main {
		position: absolute;
	}

	.main-container {
		display: flex;
		flex-direction: row;
		position: relative;
	}

	.globe-inner {
		height: 100%;
	}

	.full-container {
		/* height: 100vh; */
		/*overflow: hidden;*/
	}

	.cnt-sec {
		position: absolute;
		width: 42%;
		/* height: 100%; */
		top: 50%;
		transform: translate(0, -50%);
		/* font-size: 25px; */
		/* left: 0; */
	}

	.cnt-sec h1,
	.text-sec h1 {
		font-size: 55px;
	}

	.cnt-sec p {
		font-size: 20px;
		padding-right: 146px;
	}

	.text-sec p {
		font-size: 20px;
	}

	.cnt-main {
		display: flex;
		max-width: 1366px;
		height: 100vh;
		margin: auto;
	}

	.container-sec {
		max-width: 1366px;
		margin: auto;
		margin-top: 150px;
	}

	.text-sec {
		width: 66%;
		margin: auto;
		text-align: center;
	}

</style>

<body>

	<div id = 'Ap' /></div >
	
	<script type='text/babel'>
			
		const Globe = props => {
			const [ states, set_states ]    = React . useState ( [  ] )
			const container_ref             = React . useRef   ( null )	
			
			let   canvas
			let   context
			
			const width                        = props . width
			const height                       = props . height
			
			const globe_radius                 = 5
			const Deg2Rad                      = Math.PI / 180
			const Rad2Deg                      = 180 / Math.PI
			let   scene                        = null
			let   camera                       = null
			let   renderer                     = null
			let   render_target			
			let   raycaster                    = null
			const data_point_threshold         = .75 
			let   spinner_mesh
			let   spinner_mesh_frame_index     = 0
			let   spinner_mesh_tts             = 2
			let   spinner_mesh_current_tts     = 0
			let   beacon_texture_frames
			let   beacon_image
			let   leash_strength               = 3			
			let   sphere
			
			let   marker_modes                 = {
				hidden: 0,
				raining: 1,
				normal: 2,
				mode: 0,
			}
			let   rain                         = {
				start: 0,
				origin: null,
				delay: 1 * 1000,
				duration: 3 * 1000,
				curvature: 2,
				direction: { x: 0, y: 1, z: 1 },
				distance: globe_radius * 3,
				control_point: new THREE.Vector3(0, 0, 0)
			}
			const Pointers                     = {
				position      : new THREE . Vector2 () ,
				down_position : new THREE . Vector2 () ,
				old_position  : new THREE . Vector2 () ,
				delta         : new THREE . Vector2 () ,
				wil_delta     : 0                      ,
				button        : - 1                    ,
				left_button   : 0                      ,
				middle_button : 1                      ,
				right_button  : 2                      ,
				target        : null                   ,
			}
			
			let   mouse = new THREE . Vector2 ()
			let   maximum_selection_distance   = 300
			
			let   tunnel                       = null
			let   gl_canvas			
			
			let   planet_clouds_stars_and_portal_group
			
			class Post                                   {
				constructor ( args ) {
					this . scene  = new THREE.Scene()
					this . camera = new THREE.
					  PerspectiveCamera(
					  75, 
					  width / height , //canvasContainer.offsetWidth / canvasContainer.offsetHeight,
					  0.1,
					  1000
					)

					//new renderer
					this . gl_canvas           = document . createElement ( 'canvas' )
					this . gl_canvas . width   = width
					this . gl_canvas . height  = height

					this . renderer            = new THREE.WebGLRenderer  ( { canvas : this . gl_canvas , alpha : true , antialias : false } )
					this . renderer  . setSize                            ( width , height )
					
					this . mesh                = new THREE . Mesh (
						new THREE . PlaneGeometry ( 2 , 2 ) ,
						new THREE . ShaderMaterial ( {
							vertexShader: `
								varying vec2 UV ;

								void main () {
									UV          = uv ;
									gl_Position = vec4 ( position , 1. ) ;
								}` ,
							fragmentShader: `
								uniform float u_date ;
								uniform vec2  u_resolution ;

								varying vec2 UV ;
								
								void main () {
								/*
									//vec2  uv      = ( gl_FragCoord . xy - .5 * u_resolution . xy ) / u_resolution . y ;
									vec2  uv      = UV * 2. - 1. ;
									uv           *= 3. ;
									vec3  col     = vec3 ( 0 ) ;
									float d       = length ( uv ) ;
									float m       = .02 / d ;
									col          += m ;
									
									//float rays    = max ( 0. , 1. - abs ( uv . x * uv . y * 10. ) ) ;
									float rays    = 1. - abs ( uv . x * 10000. )  ;
									col          += rays ;
									
									gl_FragColor  = vec4 ( col , 1. ) ;
								*/
									vec2 R = u_resolution . xy ;
									vec2 U = abs ( u + u - R ) ;
									gl_FragColor = vec4 ( U . x < min ( .5 * R , R - U * 1.7 ) . y ) ;								
								}
							`, 
						})
					)
					this . scene . add ( this . mesh )
				}
				render      ( args ) {
					if ( ! args ) return
					if ( ! 'texture_map' in args ) return
					
					//this . mesh     . material . uniforms . texture_map . value = args . texture_map
					//this . mesh     . material . uniforms . texture_map . value = render_target . texture
					//this . mesh     . material . uniforms [ 'texture_map' ] = { value : args . texture_map }
					this . mesh     . material . uniforms [ 'u_date'       ] = { value : performance . now () }
					this . mesh     . material . uniforms [ 'u_resolution' ] = { value : new THREE . Vector2 ( this . gl_canvas . width , this . gl_canvas . height ) }
					console . log ( this . gl_canvas . width , this . gl_canvas . height )
					//this . mesh     . material . needsUpdate = true
					this . renderer . render                                  ( this . scene , this . camera )
				}
			}
			class Tunnel                                 {
				constructor          ( texture )    {
				  this.init();
				  this.createMesh(texture);

				  this.handleEvents();

				  this.initAnimation();

				  //window.requestAnimationFrame(this.render.bind(this));
				}
				init                 ( args    )    {
					const ww = window.innerWidth;
					const wh = window.innerHeight;

					this.speed = 8;

					this . mouse = {
						position : new THREE . Vector2 ( ww * 0.5 , wh * 0.5 ) ,
						ratio    : new THREE . Vector2 ( 0        , 0        ) ,
						target   : new THREE . Vector2 ( ww * 0.5 , wh * 0.5 )
					}

					this . canvas          = document . createElement ( 'canvas' )
					this . canvas . width  = canvas . width
					this . canvas . height = canvas . height

					this.renderer = new THREE.WebGLRenderer({
						antialias: true,
						canvas: this . canvas //document.querySelector("#scene")
					});
					this.renderer.setSize(ww, wh);

					this.camera = new THREE.PerspectiveCamera(15, ww / wh, 0.01, 1000);
					this.camera.rotation.y = Math.PI;
					this.camera.position.z = 0.35; // 2

					this.scene = new THREE.Scene();
				};
				createMesh           ( texture )    {
				  var points = [];
				  var i = 0;
				  var geometry = new THREE.Geometry();
				  
				  this.scene.remove(this.tubeMesh);

				  for (i = 0; i < 5; i += 1) {
					points.push(new THREE.Vector3(0, 0, 3 * (i / 4)));
				  }
				  points[4].y = -0.06;

				  this.curve = new THREE.CatmullRomCurve3(points);
				  this.curve.type = "catmullrom";

				  geometry = new THREE.Geometry();
				  geometry.vertices = this.curve.getPoints(70);
				  this.splineMesh = new THREE.Line(geometry, new THREE.LineBasicMaterial());
				  //this . scene . add ( this . splineMesh )

				  this.tubeMaterial = new THREE.MeshBasicMaterial({
					wireframe : false ,
					side: THREE.BackSide,
					map: texture
				  });
				  this.tubeMaterial.map.wrapS = THREE.MirroredRepeatWrapping;
				  this.tubeMaterial.map.wrapT = THREE.MirroredRepeatWrapping;
				  this.tubeMaterial.map.repeat.set(
					this.tubeMaterial.repx,
					this.tubeMaterial.repy
				  );

				  this.tubeGeometry = new THREE.TubeGeometry(this.curve, 70, 0.02, 30, false);
				  this.tubeGeometry_o = this.tubeGeometry.clone();
				  this.tubeMesh = new THREE.Mesh(this.tubeGeometry, this.tubeMaterial);

				  this.scene.add(this.tubeMesh);
				};
				handleEvents         ( args    )    {
				  window.addEventListener("resize", this.onResize.bind(this), false);
				  document.body.addEventListener(
					"mousemove",
					this.onMouseMove.bind(this),
					false
				  );
				};
				onResize             ( args    )    {
				  const ww = window.innerWidth;
				  const wh = window.innerHeight;

				  this.camera.aspect = ww / wh;
				  this.camera.updateProjectionMatrix();
				  this.renderer.setSize(ww, wh);
				};
				onMouseMove          ( e       )    {
					this.mouse.target.x = e.clientX
					this.mouse.target.y = e.clientY

					//this.mouse.position.x = e.clientX
					//this.mouse.position.y = e.clientY
				};
				update               ( args    )    {
				  this.createMesh();
				};
				initAnimation        ( args    )    {
				  // Timeline animation
				  this.textureParams = {
					offsetX: 0,
					offsetY: 0,
					repeatX: 10,
					repeatY: 4
				  };
				  this.cameraShake = {
					x: 0,
					y: 0
				  };
				  var self = this;
				  var hyperSpace = new TimelineMax({ repeat: -1 });
				  hyperSpace.to(this.textureParams, 4, {
					repeatX: 0.3,
					ease: Power1.easeInOut
				  });
				  hyperSpace.to(
					this.textureParams,
					12,
					{
					  offsetX: 8,
					  ease: Power2.easeInOut
					},
					0
				  );
				  hyperSpace.to(
					this.textureParams,
					6,
					{
					  repeatX: 10,
					  ease: Power2.easeInOut
					},
					"-=5"
				  );
				  var shake = new TimelineMax({ repeat: -1, repeatDelay: 5 });
				  shake.to(
					this.cameraShake,
					2,
					{
					  x: -0.01,
					  ease: RoughEase.ease.config({
						template: Power0.easeNone,
						strength: 0.5,
						points: 100,
						taper: "none",
						randomize: true,
						clamp: false
					  })
					},
					4
				  );
				  shake.to(this.cameraShake, 2, {
					x: 0,
					ease: RoughEase.ease.config({
					  template: Power0.easeNone,
					  strength: 0.5,
					  points: 100,
					  taper: "none",
					  randomize: true,
					  clamp: false
					})
				  });
				};
				updateMaterialOffset ( args    )    {
				  this.tubeMaterial.map.offset.x = this.textureParams.offsetX;
				  this.tubeMaterial.map.offset.y += 0.001;
				  this.tubeMaterial.map.repeat.set(
					this.textureParams.repeatX,
					this.textureParams.repeatY
				  );
				};
				updateCameraPosition ( args    )    { 
					const ww = window.innerWidth  ;
					const wh = window.innerHeight ;

					this.mouse.position.x += (this.mouse.target.x - this.mouse.position.x) / 50;
					this.mouse.position.y += (this.mouse.target.y - this.mouse.position.y) / 50;

					this.mouse.ratio.x = this.mouse.position.x / ww;
					this.mouse.ratio.y = this.mouse.position.y / wh;

					this.camera.position.x = this.mouse.ratio.x * 0.044 - 0.025 + this.cameraShake.x;
					this.camera.position.y = this.mouse.ratio.y * 0.044 - 0.025;
				  
				};
				updateCurve          ( args    )    {
  var i = 0;
  var index = 0;
  var vertice_o = null;
  var vertice = null;
  for (i = 0; i < this.tubeGeometry.vertices.length; i += 1) {
    vertice_o  = this.tubeGeometry_o.vertices[i];
    vertice    = this.tubeGeometry.vertices[i];
	
    index      = Math.floor(i / 30);
	
    vertice.x += (vertice_o.x + this.splineMesh.geometry.vertices[index].x - vertice.x) / 15;
    vertice.y += (vertice_o.y + this.splineMesh.geometry.vertices[index].y - vertice.y) / 15;
  }
  this.tubeGeometry.verticesNeedUpdate = true;

  this.curve.points[2].x = 0.6 * (1 - this.mouse.ratio.x) - 0.3;
  this.curve.points[3].x = 0;
  this.curve.points[4].x = 0.6 * (1 - this.mouse.ratio.x) - 0.3;

  this.curve.points[2].y = 0.6 * (1 - this.mouse.ratio.y) - 0.3;
  this.curve.points[3].y = 0;
  this.curve.points[4].y = 0.6 * (1 - this.mouse.ratio.y) - 0.3;

  this.splineMesh.geometry.verticesNeedUpdate = true;
  this.splineMesh.geometry.vertices = this.curve.getPoints(70);				};
				render               ( args    )    {
				  this.updateMaterialOffset();

				  this.updateCameraPosition();

				  this.updateCurve();

				  this.renderer.render(this.scene, this.camera);

				  //window.requestAnimationFrame(this.render.bind(this));
				};
			}			
			const Quadratic_bezier_at          = args => {
				let t = args.t
				let one_minus_t = 1 - t
				let one_minus_t_2 = one_minus_t * one_minus_t

				return new THREE.Vector3(
					one_minus_t_2 * args.p0.x + 2 * one_minus_t * t * args.c.x + t * t * args.p1.x,
					one_minus_t_2 * args.p0.y + 2 * one_minus_t * t * args.c.y + t * t * args.p1.y,
					one_minus_t_2 * args.p0.z + 2 * one_minus_t * t * args.c.z + t * t * args.p1.z)
			}			
			const Lat_lon_to_cartesian         = args => {
			/*
				const phi   = ( 90 - args . lat ) * Deg2Rad
				const theta = (    - args . lon ) * Deg2Rad
				return {
					x : globe_radius * Math . sin ( phi ) * Math . cos ( theta ) ,
					y : globe_radius * Math . cos ( phi ) ,
					z : globe_radius * Math . sin ( phi ) * Math . sin ( theta )
				}
					function Lat_lon_to_cartesian(args){
					  const phi = (90 - args.lat ) * Math.PI / 180
					  const theta = (90 - args.lon ) * Math.PI / 180
					  return {
						x: globe_radius * Math.sin(phi) * Math.cos(theta),
						y: globe_radius * Math.cos(phi),
						z: globe_radius * Math.sin(phi) * Math.sin(theta)
					  }
					  */
					  const latitude = (args . lat / 180) * Math.PI
					  const longitude = (args . lon / 180) * Math.PI
					  return {
						x: globe_radius * Math.cos(latitude) * Math.sin(longitude) ,
						y: globe_radius * Math.sin(latitude) ,
						z: globe_radius * Math.cos(latitude) * Math.cos(longitude)
					  }
			}
			const Ddd2dd                       = args => {
				const vector = new THREE.Vector3()
				const widthHalf = 0.5 * renderer.getContext().canvas.width
				const heightHalf = 0.5 * renderer.getContext().canvas.height

				args.object3D.updateMatrixWorld()
				vector.setFromMatrixPosition(args.object3D.matrixWorld)
				vector.project(camera)

				vector.x = (vector.x * widthHalf) + widthHalf
				vector.y = - (vector.y * heightHalf) + heightHalf

				return new THREE.Vector2(vector.x, vector.y)
			}
			const Mouse_over_globe             = args => {
				let de = renderer.domElement
				let ol = renderer.domElement.offsetLeft
				let ot = renderer.domElement.offsetTop
				while (de.parentElement != null) {
					de = de.parentElement
					ol += de.offsetLeft
					ot += de.offsetTop
				}

				mouse.x = ((Pointers.position.x - ol) / renderer.domElement.clientWidth) * 2 - 1;
				mouse.y = - ((Pointers.position.y - ot) / renderer.domElement.clientHeight) * 2 + 1;
				raycaster.setFromCamera(mouse, camera)
				let intersection_objects = raycaster.intersectObject( sphere , true)
				return intersection_objects.length > 0
			}
			const Evento_at                    = args => {
				let result = null
				let de = renderer.domElement
				let ol = renderer.domElement.offsetLeft
				let ot = renderer.domElement.offsetTop
				while (de.parentElement != null) {
					de = de.parentElement
					ol += de.offsetLeft
					ot += de.offsetTop
				}

				mouse.x = ((Pointers.position.x - ol) / renderer.domElement.clientWidth) * 2 - 1;
				mouse.y = - ((Pointers.position.y - ot) / renderer.domElement.clientHeight) * 2 + 1;
				// mouse.x = (Pointers.position.x / width) * 2 - 1
				// mouse.y = (- Pointers.position.y / height) * 2 + 1
				raycaster.setFromCamera(mouse, camera)
				let intersection_objects = raycaster.intersectObject(sphere, true)
				if (intersection_objects.length > 0) {
					let intersection = intersection_objects[0]

					let min_distance_squared = 1000 * 1000
					let min_evento = null
					for ( const evento of Evento . Eventos ) {
						let distance_squared = intersection.point.distanceToSquared(evento.mesh.position)
						if (distance_squared < min_distance_squared) {
							min_distance_squared = distance_squared
							min_evento = evento
						}
					}
					if (min_evento != null && min_distance_squared < (maximum_selection_distance * maximum_selection_distance))
						result = min_evento
				}
				return result
			}

			class Lat_lon                                {
				constructor ( args ) {
					this . lat = 0
					this . lon = 0
					
					if ( args ) {
						if ( 'lat' in args ) this . lat = args . lat
						if ( 'lon' in args ) this . lon = args . lon
					}
				}
			}
			class Marker extends Lat_lon                 {
				static Instances   = []
				static Marker_size = .25
				static Mesh_group  = new THREE . Group ()
				
				static Animate_markers              = args => {
					let tile_vector        = new THREE . Vector3  ()
					let nt                 = 0
					let rain_time_elapsed  = new Date() . getTime () - rain . start
					
					for ( let [ index , marker ] of Marker . Instances . entries () ) { 
						marker . intensity += marker . intensity_step
						if ( marker . intensity > 1 ) {
							marker . intensity = 1
							marker . intensity_step = - marker . intensity_step
						}
						if ( marker . intensity < .5 ) {
							marker . intensity = .5
							marker . intensity_step = - marker . intensity_step
						}
						marker . mesh . rotation . z += .005
						marker . mesh . scale . x = 2 * marker . intensity
						marker . mesh . scale . y = 2 * marker . intensity
						
						marker . mesh . material . uniforms [ 'u_intensity'  ] = { value : marker . intensity }
						marker . mesh . material . uniforms [ 'u_time'       ] = { value : performance . now () / 10000 }
						marker . mesh . material . uniforms [ 'u_resolution' ] = { value : new THREE . Vector2 ( Marker . Marker_size , Marker . Marker_size ) }
						
						const cartesian = Lat_lon_to_cartesian ( { lat : marker . lat , lon : marker . lon } )
						tile_vector . set ( cartesian . x , cartesian . y , cartesian . z )
					
						if ( marker_modes . raining == marker_modes . mode ) {
							let t = rain_time_elapsed / marker . t
							if ( t > 1  ) t = 1
							if ( t != 1 ) nt++
							rain . control_point . copy           ( tile_vector )
							rain . control_point . multiplyScalar ( rain . curvature )
							let position = Quadratic_bezier_at    ( { t : t , c : rain . control_point , p0 : rain . origin , p1 : tile_vector } )
							marker . mesh . position . copy ( position )
						}
					}
					if ( marker_modes . raining == marker_modes . mode )
						if ( nt == 0 ) 
							marker_modes . mode = marker_modes . normal
				}
				
				constructor ( args ) {
					super ( args )
					
					const p = performance . now ()
					this . intensity      = Math . random () //p - Math . floor ( p )
					this . intensity_step = 0.005
					
					this . t = Math . random () * ( rain . duration - 1000 ) + 1000
					
					this . mesh = new THREE . Mesh ( 
						new THREE . PlaneGeometry ( Marker . Marker_size , Marker . Marker_size ) , 
						new THREE . ShaderMaterial ( { 
							depthTest    : false ,
							transparent  : true ,
							vertexShader : `
								varying vec2 UV ;

								void main() {
									UV = uv ;
									gl_Position = projectionMatrix * modelViewMatrix * vec4 ( position , 1.0 ) ;
								}` ,
							fragmentShader : `
								uniform float u_intensity ;
								uniform float u_time ;
								uniform vec2  u_resolution ;
								
								varying vec2  UV ;
									
								#define r(x)     fract(1e4*sin((x)*541.17))      // rand, signed rand   in 1, 2, 3D.
								#define sr2(x)   ( r(vec2(x,x+.1)) *2.-1. )
								#define sr3(x)   ( r(vec4(x,x+.1,x+.2,0)) *2.-1. )

								float flare( vec2 U ) {	
									vec2 A = sin(vec2(0, 1.57) + u_time);
									U = abs( U * mat2(A, -A.y, A.x) ) * mat2(2,0,1,1.7); 
									return .2/max(U.x,U.y);                      // glowing-spiky approx of step(max,.2)
									//return .2*pow(max(U.x,U.y), -2.);
								}

								void main() {
								
								/*
									vec2  uv     = UV / 4. ; //- 1. ;
									vec2  xy     = u_resolution . xy ;
									vec2  U      = abs ( uv + uv - xy ) ;
									float i      = 0. ;
									float min_y  = min ( .5 * xy , xy - U * 1.7 ) . y ;
									if ( U . x < min_y  ) i = .5 / max ( U . x , U . y ) ;
									i *= fract ( u_time ) ;
									gl_FragColor = vec4 ( i , i , 0 , i ) ;
								*/
								/*
									vec2  uv     = UV / 4. ;
									vec2  xy     = u_resolution . xy ;
									vec2  U      = abs ( uv + uv - xy ) ;
									float i      = 0. ;
									float min_y  = min ( .5 * xy , xy - U * 2. ) . y ;
									if ( U . x < min_y  ) i = 1. ; //.5 / max ( U . x , U . y ) ;
									i *= u_intensity ;
									gl_FragColor = vec4 ( i , i , 0 , i ) ;
								*/
								
								float f = 1./2.; //  NB: 1./2. crash WebGL driver on Linux/chrome ! 
								vec2  U = UV / 4. ;
								U = abs(U+U - (gl_FragColor.xy=u_resolution.xy)) / gl_FragColor.y;
								gl_FragColor += flare ( U ) + 1. - 2.*pow((  pow(2.*U.x, f) + pow(U.x + U.y*1.7, f) + pow(abs(U.x - U.y*1.7), f) )/3., 1./f) -gl_FragColor;
								float i = ( gl_FragColor . r + gl_FragColor . g + gl_FragColor . b ) / 3. ;
								i *= u_intensity ;
								gl_FragColor = vec4 ( i , i , 0 , i ) ;
								
								/*
								vec2 R = u_resolution.xy;
								vec2 U = UV / 4. ;
								U =  (U+U - R) / R.y;
								gl_FragColor -= gl_FragColor+.3;
								float i = 0. ;
								//for (float i=0.; i<99.; i++)
									gl_FragColor += flare (U - sr2(i)*R/R.y )           // rotating flare at random location
									                * r(i+.2)                          // random scale
									                * (1.+sin(u_time+r(i+.3)*6.))*.1  // time pulse
									                //* (1.+.1*sr3(i+.4));               // random color - uncorrelated
									                * (1.+.1*sr3(i));                  // random color - correlated
								*/
								}								
							` ,
						} )
					)
					const cartesian = Lat_lon_to_cartesian ( { lat : this . lat , lon : this .lon } )
					this . mesh . lookAt         ( cartesian . x        , cartesian . y      , cartesian . z ) 
					this . mesh . position . set ( cartesian . x        , cartesian . y      , cartesian . z )
					this . mesh . rotation . z   = Math . random () * Math . PI * 2
					
					Marker . Instances  . push ( this )
					Marker . Mesh_group . add  ( this . mesh )
				}
			}
			class Evento                                 {
				static Eventos = []
				static Showed  = null
				static Showed_last  = 0
				
				constructor ( args ) {
					this . creation       = Date . now ()
					this . lat            = 0
					this . lon            = 0
					this . mesh           = null
					this . div            = null
					this . html           = ''
					this . image          = null
					this . texture_frames = []
					this . old_dot
					this . curve_start
					this . curve_factor

					let found = false
					let i = 0
					while ( ! found && i < Evento . Eventos . length)
						found = Evento . Eventos [ i ++ ] . creation == args . creation
					if (!found) {
						if (args) {
							if ( 'creation' in args ) this . creation = args . creation
							if ( 'lat'      in args ) this . lat      = args . lat
							if ( 'lon'      in args ) this . lon      = args . lon
							if ( 'width'    in args ) this . width    = args . width
							if ( 'height'   in args ) this . height   = args . height
							if ( 'image'    in args ) this . image    = args . image
							//if ( 'html'     in args ) if ( args . html != '' ) this . html = args . html
						}

						if (this.html == '') {
							this.html += '<div>'
							//if ('card_flag' in args) this.html += '<div class="card_flag_img"><img src = "' + args.card_flag + '"/></div>'
							//if ('card_flag' in args) this.html += '<img src = "' + args.card_flag + '"/>'
							//this.html += '<div class="card_info_main">'
							if ('card_title' in args) this.html += '<label>' + args.card_title + '</label>'
							//if ('card_title' in args) this.html += '<h3>' + args.card_title + '</h3>'
							if ('card_subtitle' in args) this.html += '<p>' + args.card_subtitle + '</p>'
							//this.html += '</div>'
							this.html += '</div>'
						}

						let meshBasicMaterial
						if (this.texture_frames.length > 0) meshBasicMaterial = new THREE.MeshBasicMaterial({ map: this.texture_frames[0], transparent: true, side: THREE.DoubleSide })
						else meshBasicMaterial = new THREE.MeshBasicMaterial({ side: THREE.DoubleSide, transparent: true })

						this.mesh = new THREE.Mesh(new THREE.PlaneGeometry(states.point_side, states.point_side), meshBasicMaterial)
						let cartesian = Lat_lon_to_cartesian({ lat: this.lat, lon: this.lon })
						this.mesh.position.set(cartesian.x, cartesian.y, cartesian.z)
						this.mesh.rotation.set(- this.lat * Deg2Rad, this.lon * Deg2Rad, 0, 'YXZ')
						this.frame_index = Math.floor(Math.random() * this.texture_frames.length)
						this.tts = 3
						this.current_tts = 0

						this.div = document.createElement('div')
						this.div.style.position = 'absolute'
						this.div.style.background = 'white'
						this.div.style.display = 'none'
						//this.div.style.padding = '1vmax'
						this.div.className = 'Card_div fade-in-image'
						this.div.innerHTML = this.html
						container_ref.current.appendChild(this.div)
						//canvas.appendChild(this.div)
						//renderer.domElement.appendChild(this.div)

						let v_camera = new THREE.Vector3()
						v_camera.subVectors(camera, this.mesh.position)
						this.old_dot = v_camera.dot(v_camera)

						if ( Evento . Showed != null )
							Evento . Showed . hide ()

						Evento . Eventos . push(this)
					}
				}
				hide() {
					this.div.style.display = 'none'

					Evento . Showed = null
					Evento . Showed_last = new Date().getTime()
				}
				show() {
					Evento . Showed = this

					this.curve_start = new Date().getTime()
					this.curve_factor = 0
					this.div.style.display = 'block'

					let cartesian = Lat_lon_to_cartesian({ lat: this.lat, lon: this.lon })
					//spinner_mesh.position.set(cartesian.x, cartesian.y, cartesian.z)
					//spinner_mesh.rotation.set(- this.lat * Deg2Rad, this.lon * Deg2Rad, 0, 'YXZ')
				}
			}
			const Rain                         = args => {
				rain . origin                   = new THREE . Vector3 ( rain . direction . x, rain . direction . y , rain . direction . z )
				rain . origin . applyQuaternion                       ( camera . quaternion ) . normalize ()
				rain . origin . multiplyScalar                        ( rain . distance )

				marker_modes  . mode            = marker_modes . raining
				rain          . start           = new Date() . getTime ()
			}
			const Animate_eventos              = args => {
				//context . clearRect ( 0 , 0 , canvas . width , canvas . height )
				
				const cw = container_ref.current.clientWidth
				const ch = container_ref.current.clientHeight
/*
				if (--spinner_mesh_current_tts < 0) {
					spinner_mesh_current_tts = spinner_mesh_tts

					if (++spinner_mesh_frame_index >= beacon_texture_frames.length)
						spinner_mesh_frame_index = 0

					spinner_mesh.material.map = beacon_texture_frames[spinner_mesh_frame_index]
					spinner_mesh.material.needsUpdate = true
				}
*/
				let v_camera = new THREE.Vector3()
				if (Evento . Showed != null) {
					v_camera.subVectors(camera.position, Evento . Showed.mesh.position)
					let dot = Evento . Showed.mesh.position.dot(v_camera)
					if (dot < 0)
						Evento . Showed.hide()
				}

				for (let evento of Evento . Eventos) {
					v_camera.subVectors(camera.position, evento.mesh.position)
					let dot = evento.mesh.position.dot(v_camera)
					evento.mesh.visible = dot >= 0

					if (--evento.current_tts < 0) {
						evento.current_tts = evento.tts
/*
						if (++evento.frame_index >= data_texture_frames.length)
							evento.frame_index = 0

						evento.mesh.material.map = data_texture_frames[evento.frame_index]
						evento.mesh.material.needsUpdate = true
*/
					}
				}

				let q = new THREE.Vector2()
				if ( Evento . Showed != null) {
					//Evento . Showed.mesh.visible = false

					const ew = Evento . Showed.div.clientWidth
					const eh = Evento . Showed.div.clientHeight

					v_camera.subVectors(camera.position, Evento . Showed.mesh.position)
					let dot = Evento . Showed.mesh.position.dot(v_camera)

					const p = Ddd2dd({ object3D: Evento . Showed.mesh })

					const r = Ddd2dd({ object3D: sphere })

					q.set(p.x + ew / 4, 0)
					let dir = new THREE.Vector2()
					//let r   = new THREE.Vector2 ( q . x + ew / 2 , q . x + ew / 2 )
					dir.subVectors(q, p)
					let len = dir.length()
					if (len > ch / leash_strength) len = ch / leash_strength
					q.lerp(p, 1 - len / dir.length())

					if (q.x > r . x ) q.x = r . x

					let q2x = q.x + ew / 2

					Evento . Showed.div.style.left = q.x + 'px'
					Evento . Showed.div.style.top = q.y + 'px'

					const to_vector2      = new THREE . Vector2 ()
					const control_vector2 = new THREE . Vector2 ()
					if ( p . x <= q . x ) {
						let y_t = 1 - ( q . x - p . x ) / ( ew / 4 )
						if ( y_t > 1 ) y_t = 1
						let y = q . y + eh / 2 + y_t * ( eh / 2 ) + 4
						to_vector2 . set ( q . x - 6 , y )
						control_vector2 . set ( q . x - ew / 4 * ( 1 - y_t ) , y )
					} else {
						let x = p . x
						if ( x > q . x + ew / 2 ) x = q . x + ew / 2
						to_vector2 . set ( x , q . y + eh + 6 )
						control_vector2 . set ( p . x , q . y + eh + 6 )
					}

					let curve_time_elapsed = new Date().getTime() - Evento . Showed.curve_start
					let curve_t = curve_time_elapsed / 250
					if (curve_t > 1) curve_t = 1
					let x = p.x + (to_vector2 . x - p.x) * curve_t
					let y = p.y + (to_vector2 . y - p.y) * curve_t

					context . strokeStyle = 'white'
					context . lineWidth = 2
					context . beginPath ()
					context . moveTo ( p . x , p . y - 3)
					context . quadraticCurveTo ( control_vector2 . x , control_vector2 . y , x , y )
					context . stroke ()

					context . fillStyle = 'white'
					context.beginPath()
					context.arc(x, y, 3, 0, 2 * Math.PI)
					context.fill()

					context . fillStyle = 'white'
					context.beginPath()
					context.arc(p.x, p.y, 3, 0, 2 * Math.PI)
					context.fill()
				}
			}			
			const Image_to_texture_frames      = args => {
				let result = []
				let n = args.image.width / args.image.height
				for (let i = 0; i < n; i++) {
					let canvas = document.createElement('canvas')
					canvas.width = args.image.height
					canvas.height = args.image.height
					let context = canvas.getContext('2d')
					context.drawImage(
						args.image,
						- i * args.image.height,
						0)
					let texture = new THREE.CanvasTexture(canvas)
					texture.magFilter = THREE.NearestFilter
					texture.minFilter = THREE.NearestFilter
					texture.needsUpdate = true
					result.push(texture)
				}
				return result
			}
			const Load_image                   = args => {
				return new Promise((resolve, reject) => {
					let img = document.createElement('img')
					img.addEventListener('load', function (event) {
						resolve({ image: img })
					})
					img.src = args.image_source
				})
			}

			const create_scene                 = async args => {
				const Init_ThreeJS   = args => {
					canvas                                = document . createElement ( 'canvas' )
					canvas        . width                 = width
					canvas        . height                = height
					canvas        . style . position      = 'absolute'			
					context                               = canvas . getContext ( '2d' )
					//context       . fillStyle             = '0x031928'
					//context       . fillRect              ( 0 , 0 , canvas . width , canvas . height )
					context . clearRect ( 0 , 0 , canvas . width , canvas . height )
					container_ref . current . appendChild ( canvas )

					/*
					const canvas = document . createElement ( 'canvas' )
					const context = canvas . getContext ( '2d' )
					context . fillStyle = 'red'
					context . fillRect ( 0 , 0 , canvas . width , canvas . height )
					container_ref . current . appendChild ( canvas )
					*/
					
					/*
					import './style.css'
					import * as THREE from 'three'
					import gsap from 'gsap'
					import countries from './countries.json'
					import vertexShader from './src/shaders/vertex.glsl'
					import fragmentShader from './src/shaders/fragment.glsl'
					import atmosphereVertexShader from './src/shaders/atmosphereVertex.glsl'
					import atmosphereFragmentShader from './src/shaders/atmosphereFragment.glsl'
					import globe from './src/img/globe.jpeg?url'
					import cloud from './src/img/earthCloud.png?url'
					import smoke from './src/img/smoke.png?url'
					import { OrbitControls } from 'three/addons/controls/OrbitControls.js'
					*/

					let portal
					let post

					const canvasContainer = container_ref . current // document . querySelector('#canvasContainer')
					
					//new scene
					scene = new THREE.Scene()
					camera = new THREE.
					  PerspectiveCamera(
					  75, 
					  width / height , //canvasContainer.offsetWidth / canvasContainer.offsetHeight,
					  0.1,
					  1000
					)

					//new renderer
					gl_canvas          = document . createElement ( 'canvas' )
					gl_canvas . width  = width
					gl_canvas . height = height

					renderer                              = new THREE.WebGLRenderer ( { canvas : gl_canvas , alpha : true , antialias : false } )
					//renderer = new THREE.WebGLRenderer( /*{ canvas: document.querySelector('canvas') }*/ )
					
					renderer.setSize( width , height )//canvasContainer.offsetWidth, canvasContainer.offsetHeight)
					renderer . autoClear = false 
					//renderer.setPixelRatio(window.devicePixelRatio)
					canvasContainer . appendChild ( renderer . domElement )
					
					render_target = new THREE . WebGLRenderTarget ( width , height )

					raycaster = new THREE . Raycaster ()

					const controls = new THREE.OrbitControls(camera, canvas ) //renderer.domElement);
					controls.enableDamping = true;
					controls.dampingFactor = 0.05;
					controls.enableZoom = true;
					controls.enablePan = false;

					// create a sphere
					sphere = new THREE.Mesh(
					  new THREE.SphereGeometry(globe_radius, 50, 50),
					  //new THREE.MeshStandardMaterial ( { map : new THREE.TextureLoader().load('./assets/globe.jpeg') } )
					  new THREE.ShaderMaterial( {
						vertexShader : `
							varying vec2 vertexUV;
							varying vec3 vertexNormal;

							void main() {
							vertexUV = uv;
							vertexNormal = normalize(normalMatrix * normal);

							gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
						}` ,
						fragmentShader : `
							uniform sampler2D globeTexture;

							varying vec2 vertexUV;
							varying vec3 vertexNormal;


							void main() {
								float intensity = 1.05 - dot(vertexNormal, vec3(0.0, 0.0, 1.0 ));
								vec3 atmosphere = vec3(0.3, 0.6, 1.0) * pow(intensity, 1.5);

								gl_FragColor = vec4(atmosphere + texture2D(globeTexture, vertexUV).xyz, 1.0);
							}							
						` ,
						uniforms: {
						  globeTexture: {
							value: new THREE.TextureLoader().load('./assets/globe.jpeg')
						  }
						}
					  })
					)
					//scene.add(sphere)

					//clouds
					const clouds = new THREE.Mesh(
					  new THREE.SphereGeometry(globe_radius + 0.1, 50, 50),
					  new THREE.MeshBasicMaterial({
						map: new THREE.TextureLoader().load('./assets/earthCloud.png'),
						transparent: true,
						depthWrite : false
					  })
					)
					//scene.add(clouds)
/*
					// create atmosphere
					const atmosphere = new THREE.Mesh(
					  new THREE.SphereGeometry(globe_radius, 50, 50),
					  new THREE.ShaderMaterial({
						vertexShader: atmosphereVertexShader,
						fragmentShader: atmosphereFragmentShader,
						blending: THREE.AdditiveBlending,
						side: THREE.BackSide
					  })
					)

					atmosphere.scale.set(1.1, 1.1, 1.1)

					scene.add(atmosphere)
*/

					//create stars
/* 					const starGeometry = new THREE.BufferGeometry()
					const starMaterial = new THREE.PointsMaterial ({
					  color: 0xffffff
					})

					const starVertices = []
					for (let i = 0; i < 10000; i++) {
						const x = (Math.random() - 0.5) * 1000
						const y = (Math.random() - 0.5) * 1000
						const z = (Math.random() - 0.5) * 1000
						starVertices.push(x, y, z)
					}

					starGeometry.setAttribute('position', 
					  new THREE.Float32BufferAttribute(
					  starVertices, 3))

					  const stars = new THREE.Points(
						starGeometry, starMaterial)
						
						planet_clouds_stars_and_portal_group . add                     ( stars )
*/
					
					planet_clouds_stars_and_portal_group       = new THREE . Group ()
					planet_clouds_stars_and_portal_group . add                     ( sphere )
					planet_clouds_stars_and_portal_group . add                     ( clouds )
					
					camera.position.z = 10

					function createBoxes(countries){
						let creation = 0
					  countries.forEach(country => {
						const scale = country.population / 1000000000
						const lat = country.latlng[0]
						const lng = country.latlng[1]
						const zScale = 0.8 * scale
						
					/*
					  const box = new THREE.Mesh(
					  new THREE.BoxGeometry(
						Math.max(0.1, 0.1 * scale), 
						Math.max(0.1, 0.1 * scale), 
						Math.max(zScale, 0.4 * Math.random())
					  ),
					  new THREE.MeshBasicMaterial({
						color: '#3BF7FF',
						opacity: 0.4,
						transparent: true
					  })
					  )

					  const latitude = (lat / 180) * Math.PI
					  const longitude = (lng / 180) * Math.PI

					  const x = globe_radius * Math.cos(latitude) * Math.sin(longitude)
					  const y = globe_radius * Math.sin(latitude)
					  const z = globe_radius * Math.cos(latitude) * Math.cos(longitude)

					  box.position.x = x
					  box.position.y = y
					  box.position.z = z

					  box.lookAt(0, 0, 0)
					  box.geometry.applyMatrix4(new THREE.
						Matrix4().makeTranslation(0, 0, -zScale / 2))

					  group.add(box)

					//animation box scale
					  // gsap.to(box.scale, {
					  //   z: 1.4,
					  //   duration: 2,
					  //   yoyo: true,
					  //   repeat: -1,
					  //   ease: 'linear',
					  //   delay: Math.random()
					  // })

					  box.country = country.name //change this later
					  box.population = new Intl. NumberFormat().format(country.population)//change this later
					*/
					  const marker = new Marker ( { 
						description : country.name ,
						lat ,     //         : latitude , 
						lon : lng //         : longitude ,
					  } )
					  //scene . add ( marker . mesh )					  
					  
					  new Evento ( {
						creation ,
						lat ,
						lon : lng ,
						card_title : country.name ,
						card_subtitle: new Intl. NumberFormat().format(country.population),
					  } )
					  creation ++
					  } )
					  
						Rain ()
					  
					}
					
					fetch('./countries.json')
						.then((response) => response.json())
						.then((json) => createBoxes(json));					

					sphere.rotation.y = -Math.PI / 2
					//group.rotation.offset = { x: 0, y: 0 }

					const mouse = {
					  x: undefined,
					  y: undefined,
					  down: false,
					  xPrev: undefined,
					  yPrev: undefined
					}

					//const raycaster = new THREE.Raycaster();
					const popUpEl = document.querySelector('#popUpEl')
					const populationEl = document.querySelector('#populationEl') //change
					const populationValueEl = document.querySelector('#populationValueEl') //change

					canvasContainer.addEventListener("resize", onWindowResize, false);

					function onWindowResize() {
					  //camera.aspect = canvasContainer.offsetWidth / canvasContainer.offsetHeight;
					  //camera.updateProjectionMatrix();

					  //renderer.setSize(canvasContainer.offsetWidth, canvasContainer.offsetHeight);
					}

					//mobile resonsiveness
					//longitude and latitude to cartisan for portal
					function Lat_lon_to_cartesian(args){
					  const phi = (90 - args.lat ) * Math.PI / 180
					  const theta = (90 - args.lon ) * Math.PI / 180
					  return {
						x: globe_radius * Math.sin(phi) * Math.cos(theta),
						y: globe_radius * Math.cos(phi),
						z: globe_radius * Math.sin(phi) * Math.sin(theta)
					  }
					}

					//add Thanos Portal
					class Portal extends THREE.Group {
					  constructor(args) {
						super(args)
						
						this.scene = new THREE.Scene ()
						this.camera = new THREE.PerspectiveCamera(80, 1, 0.1, 10000)
						this.camera.position.z = 1000
						this.canvas  = document.createElement( 'canvas' )
						this.renderer = new THREE . WebGLRenderer( { canvas: this.canvas, alpha: true } )
						this.renderer.setClearAlpha ( 0 )
						
						this.clock = new THREE.Clock ()
						
						this.plane = new THREE.Mesh(new THREE.PlaneGeometry(args.radius, args.radius), 
						new THREE.MeshBasicMaterial( { transparent : true } ))
						this.add(this.plane)
						
						this . set_lat_lon ( args )
						
						this . particles = []
						
							this . sceneLight = new THREE . DirectionalLight ( 0xffffff ,0.5 )
							this . sceneLight . position  . set              ( 0 , 0 , 1 )
						this . scene      . add                          ( this . sceneLight )
						
						this . light      = new THREE  . PointLight      ( 0x062d89 , 30 , 600 , 1.7 )
							this . light      . position   . set             ( 0 , 0 , 250 )
						this . scene      . add                          ( this . light )
						
						let loader = new THREE . TextureLoader ()
						loader . load ( './assets/smoke.png' , texture => {
						  const portalGeo      = new THREE . PlaneGeometry ( 350 , 350 )
						  const portalMaterial = new THREE . MeshStandardMaterial   ( {
							map         : texture ,
							transparent : true
						  } )
						  const smokeGeo       = new THREE . PlaneGeometry  ( 800 , 800 ) //orig: 900, 900
						  const smokeMaterial  = new THREE . MeshStandardMaterial ( {
							map         : texture ,
							transparent : true 
						  } )
						  
						  for ( let p = 880 ; p > 250 ; p-- ) { //orig: 880 and 250
							const particle = new THREE . Mesh ( portalGeo , portalMaterial )
							particle . position . set (
											0.5 * p * Math.cos((4 * p * Math.PI) / 180),
											0.5 * p * Math.sin((4 * p * Math.PI) / 180),
											0.1 * p
										);
							particle . rotation . z = Math . random () * 360
							 particle         . material .opacity = 1.0 //orig: 1
							this . particles . push ( particle )
							this . scene . add ( particle )
						  }
						  
						  for ( let p = 0 ; p < 40 ; p++ ) { //orig: 40
							let particle = new THREE . Mesh ( smokeGeo , smokeMaterial )
										particle.position.set(
											Math.random() * 1000-500,
											Math.random() * 400-200,
											25
										);
							particle         . rotation .z = Math.random() *360
							particle         . material .opacity = 0.6 //orig: 0.6
							this . particles . push     ( particle )
							this . scene     . add      ( particle )
								}
						} )
					  }
					  animate     ( args ) {
						let delta = this . clock . getDelta () ;
						this . particles.forEach(p => {
						  p.rotation.z -= delta *0.2; //orig: 1.5
						});
						if(Math.random() > 0.9) {
						  this . light.power =50 + Math.random()*500; //orig: 350 +....500
						}
						
						this . render ()
					  }
					  render      ( args ) {
						this . renderer . render ( this . scene , this . camera )
						const texture = new THREE . CanvasTexture ( this . canvas )
						this . plane . material . map = texture
					  }
					  set_lat_lon ( args ) {
						this . position . copy ( Lat_lon_to_cartesian ( args ) )
						this . rotation . set  ( - args . lat * Math . PI / 180 , args . lon * Math . PI / 180 , 0 , 'YXZ' )    
					  }
					}

					portal = new Portal( {radius: 3, lat: 25, lon: -40} )
					planet_clouds_stars_and_portal_group . add ( portal )
					
					post = new Post ()

					function animate () {
						context . clearRect ( 0 , 0 , canvas . width , canvas . height )
						//if ( tunnel ) {
							//tunnel . animate ()
							//context . drawImage ( tunnel . canvas , 0 , 0 )
						//}
						
						//group.rotation.y += 0.001
						clouds.rotation.y -= 0.0001
						
						
						//controls.update()


						//group.children.forEach((mesh) => {
						//mesh.material.opacity = 0.4
						//})

						Marker . Animate_markers ()
						
						if ( Mouse_over_globe () ) {
							//orbitControls . enableRotate = true

							if (Evento_at() != null)         document.body.style.cursor = 'pointer'
							else {
								if ( -1 == Pointers.button ) document.body.style.cursor = 'grab'
							  else                           document.body.style.cursor = 'grabbing'
							}
						} else {
							//orbitControls . enableRotate = false
							document.body.style.cursor = 'default'
						}
						
						
						/*
						if (marker_modes . mode == marker_modes.normal) {
							if (Evento . Showed != null) {
								if (new Date().getTime() - Evento . Showed.curve_start > 9000)
									Evento . Showed.hide()
							} else {
								if (new Date().getTime() - Evento . Showed_last > 2000) {
									let candidates = []
									let v_camera = new THREE.Vector3()
									for ( const eve of Evento . Eventos ) {
										v_camera.subVectors(camera.position, eve.mesh.position)
										v_camera.normalize()
										let v = eve.mesh.position.clone()
										v.normalize()
										let dot = v.dot(v_camera)
										if (dot >= data_point_threshold)
											candidates.push(eve)
									}
									if (candidates.length > 0) {
										let e = candidates[Math.floor(Math.random() * candidates.length)]
										e.show()
									}					
								}
							}
						} else {
							Evento . Showed_last = new Date () . getTime ()
						}					
						*/
						
						if ( tunnel ) {
							tunnel  . render    ()
							context . drawImage ( tunnel . canvas , 0 , 0 )
						}
						
						portal . animate()					


						scene    . add             ( planet_clouds_stars_and_portal_group )
						renderer . render          ( scene , camera )
						scene    . remove          ( planet_clouds_stars_and_portal_group )
						
						scene    . add             ( Marker . Mesh_group )
						renderer . render          ( scene , camera )
						scene    . remove          ( Marker . Mesh_group )

						context  . drawImage ( gl_canvas , 0 , 0 )
						
/*						
						const texture_canvas = document . createElement ( 'canvas' )
						const texture_context = texture_canvas . getContext ( '2d' )
						texture_context . fillStyle = 'red'
						texture_context . fillRect ( 0 , 0 , texture_canvas . width , texture_canvas . height )
						const texture = new THREE . CanvasTexture ( texture_canvas )
*/
						
						//const texture = new THREE . CanvasTexture ( gl_canvas )
						
						//post     . render          ( { texture_map : texture } )
						//context  . drawImage       ( post . gl_canvas , 0 , 0 )

						//context  . drawImage       ( gl_canvas , 0 , 0 )
						
/*
						scene    . add             ( planet_clouds_stars_and_portal_group )
						renderer . setRenderTarget ( render_target )
						renderer . render          ( scene , camera )
						renderer . setRenderTarget ( null )
						scene    . remove          ( planet_clouds_stars_and_portal_group )
						//context  . drawImage ( gl_canvas , 0 , 0 )
						post     . render                                                   ( { texture_map : render_target . texture } )
						context  . drawImage                                                ( post . gl_canvas , 0 , 0 )
						
						if ( marker_modes . mode  != marker_modes . hidden ) scene . add    ( Marker . Mesh_group )
						renderer . setRenderTarget                                          ( render_target )
						//renderer . clear                                                    ()
						renderer . render                                                   ( scene , camera )
						renderer . setRenderTarget                                          ( null )
						if ( marker_modes . mode  != marker_modes . hidden ) scene . remove ( Marker . Mesh_group )
						post     . render                                                   ( { texture_map : render_target . texture } )
						context  . drawImage                                                ( post . gl_canvas , 0 , 0 )
*/						
						Animate_eventos ()
						
						requestAnimationFrame(animate)
					}

					{ // pointers
					container_ref.current . addEventListener ( 'pointerdown' , function ( event ) {
						if (event.type === "touchstart") Pointers.position.set(event.touches[0].clientX, event.touches[0].clientY)
						else Pointers.position.set(event.x, event.y)

						Pointers.button = event.button

						Pointers.target = event.target

						Pointers.delta.set(0, 0)
					})
					container_ref.current . addEventListener ( 'pointermove' , function ( event ) {
						if (event.type === "touchstart") Pointers.position.set(event.touches[0].clientX, event.touches[0].clientY)
						else Pointers.position.set(event.x, event.y)

						//Pointers.button = event.button

						Pointers.target = event.target

						Pointers.delta.set(0, 0)
					})
					container_ref.current . addEventListener ( 'pointerup'   , function ( event ) {
						if (event.type === "touchstart") Pointers.position.set(event.touches[0].clientX, event.touches[0].clientY)
						else Pointers.position.set(event.x, event.y)

						Pointers.button = event.button

						Pointers.target = event.target

						Pointers.delta.set(0, 0)

					//if ( Pointers . target      != renderer . domElement ) return

						if (Pointers.left_button != Pointers.button) return

						if (Evento . showed != null)
							Evento . showed.hide()

						Evento . showed = Evento_at ()
						if ( Evento . showed != null )
							Evento . showed . show ()

						Pointers.button = - 1
					})
					}

					/*
					addEventListener('touchstart', (event) => {
					  event.clientX = event.touches[0].clientX
					  event.clientY = event.touches[0].clientY

						const doesIntersect = raycaster.intersectObject(sphere)

						if (doesIntersect.length > 0) mouse.down = true

						if (mouse.down) {
					  
						  const offset = canvasContainer.getBoundingClientRect().top

						  mouse.x = (event.clientX / innerWidth)
							* 2 - 1
						  mouse.y = -((event.clientY - offset)/ innerHeight)
							* 2 + 1

						  gsap.set(popUpEl, {
							x: event.clientX,
							y: event.clientY
						  })

						}
					  }, 
					  { passive: false }
					)

					addEventListener('touchend', (event) => {
					  mouse.down = false
					})

					canvasContainer.addEventListener('mousedown', ({clientX, clientY}) => {
					  mouse.down = true
					  mouse.xPrev = clientX
					  mouse.yPrev = clientY
					})
					
					addEventListener('mousemove', (event) => {
					  mouse.x = (event.clientX / innerWidth)
						* 2 - 1
					  mouse.y = -(event.clientY / innerHeight)
						* 2 + 1
				
					gsap.set(popUpEl, {
					  x: event.clientX,
					  y: event.clientY
					})
*/

					
					animate()
				}

				Init_ThreeJS ()
				
				const loader = new THREE . TextureLoader ()
				loader . load (
					"./assets/galaxyTexture.jepg",
					texture => {
						tunnel = new Tunnel ( texture )
					}
				)											
			}
			const destroy_scene                = args => {
				//cancelAnimationFrame ( frameId )
				//container_ref . current . removeChild ( renderer . domElement )
			}
			React . useEffect ( () => {
				if ( ! renderer ) {
					create_scene ()
				}
				
				return destroy_scene
			}, [] )	
			
			return <div ref = { container_ref } />
		}

		class Ap extends React . Component {
			constructor ( props ) {
				super( props )
				
				this . pois = [
					{ description : 'me'          , lat : 10.204577 , lon : -  68.180777 } , 
					{ description : 'you'         , lat : 55.676098 , lon :    12.568337 } , 
					{ description : 'la'          , lat : 34.0522   , lon : - 118.2437   } , 					
					{ description : 'nyc'         , lat : 40.730610 , lon : -  73.935242 } , 					
					{ description : 'eiffel'      , lat : 48.857778 , lon :     2.294876 } , 
					{ description : 'giza'        , lat : 29.980387 , lon :    31.134191 } , 
					{ description : 'teotihuacan' , lat : 19.686081 , lon : -  98.871635 } , 	
				]
			}
			render      () {
				return (
					<Globe
						width  = { window . innerWidth   }
						height = { window . innerHeight  }
						pois   = { this   . pois         }
					/>
				)
			}
		}

		ReactDOM . render ( <Ap /> , document . getElementById ( 'Ap' ) )

	</script>

</body>

</html>
